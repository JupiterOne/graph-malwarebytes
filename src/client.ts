import fetch, { Response } from 'node-fetch';
import * as qs from 'qs';
import { IntegrationProviderAuthenticationError } from '@jupiterone/integration-sdk-core';

import {
  CalculatedIntegrationConfig,
  MalwareBytesConfiguration,
  MalwareBytesEndpointWithAgent,
  MalwareBytesFinding,
  MalwareBytesGroup,
  PaginatedDataResponse,
} from './types';

export type ResourceIteratee<T> = (each: T) => Promise<void> | void;

export class APIClient {
  private readonly clientId: string;
  private readonly clientSecret: string;
  private readonly accountId: string;
  /*
    Explanation: the reason this accessToken variable is static class variable 
    is that we don't want each step function's run to request the same (new) token
    every time. This way, once accessToken value is fetched, it's shared between
    all the step functions. 
  */
  private static accessToken: string;

  constructor(readonly config: CalculatedIntegrationConfig) {
    this.accountId = config.accountId;
    this.clientId = config.clientId;
    this.clientSecret = config.clientSecret;
  }

  private withBaseUri(path: string): string {
    return `https://api.malwarebytes.com/${path}`;
  }

  private async request(
    uri: string,
    method: 'GET' | 'POST' | 'HEAD' = 'GET',
    body?: any,
  ): Promise<Response> {
    if (!APIClient.accessToken) {
      await this.getAuthenticationToken();
    }

    return await fetch(uri, {
      method,
      headers: {
        Authorization: `Bearer ${APIClient.accessToken}`,
        AccountId: this.accountId,
        'Content-Type': 'application/json',
      },
      body: body || null,
    });
  }

  private async makePaginatedRequest<K extends string, V>(
    uri: string,
    method: 'GET' | 'POST' | 'HEAD' = 'GET',
    resource: K,
    body?: any,
  ): Promise<V[]> {
    const results: V[] = [];
    let nextCursor = '';

    do {
      const response = await this.request(
        uri,
        method,
        JSON.stringify({
          ...body,
          page_size: 10,
          next_cursor: nextCursor,
        }),
      );

      const responseJson: PaginatedDataResponse<K, V[]> = await response.json();

      if (responseJson) {
        nextCursor = responseJson.next_cursor;
        results.push(...responseJson[resource]);
      }
    } while (nextCursor && nextCursor.length > 0);

    return results;
  }

  private async getAuthenticationToken() {
    const getAuthTokenEndpoint = this.withBaseUri('oauth2/token');
    const response = await fetch(getAuthTokenEndpoint, {
      method: 'POST',
      headers: {
        Authorization: `Basic ${Buffer.from(
          `${this.clientId}:${this.clientSecret}`,
        ).toString('base64')}`,
        'Content-Type': 'application/x-www-form-urlencoded',
      },
      body: qs.stringify({
        scope: 'read',
        grant_type: 'client_credentials',
      }),
    });

    try {
      const body = await response.json();
      APIClient.accessToken = body.access_token;
    } catch (e) {
      throw new IntegrationProviderAuthenticationError({
        cause: new Error('Provider authentication failed'),
        endpoint: getAuthTokenEndpoint,
        status: response.status,
        statusText: response.statusText,
      });
    }
  }

  public async verifyAuthentication(): Promise<void> {
    if (!APIClient.accessToken) {
      await this.getAuthenticationToken();
    }

    const groupsApiRoute = this.withBaseUri('nebula/v1/groups');
    const response = await this.request(groupsApiRoute);

    if (!response.ok) {
      throw new IntegrationProviderAuthenticationError({
        cause: new Error('Provider authentication failed'),
        endpoint: groupsApiRoute,
        status: response.status,
        statusText: response.statusText,
      });
    }
  }

  /**
   * Iterates each group in the provider.
   *
   * @param iteratee receives each resource to produce entities/relationships
   */
  public async iterateGroups(
    iteratee: ResourceIteratee<MalwareBytesGroup>,
  ): Promise<void> {
    const response = await this.request(this.withBaseUri('nebula/v1/groups'));
    const groupsResponse = await response.json();

    for (const group of groupsResponse.groups) {
      await iteratee(group);
    }
  }

  /**
   * Iterates each endpoint found within the requested timespan for a given group.
   *
   * @param groupName group's name
   * @param iteratee receives each resource to produce entities/relationships
   */
  public async iterateEndpoints(
    groupName: string,
    iteratee: ResourceIteratee<MalwareBytesEndpointWithAgent>,
  ): Promise<void> {
    const endpoints = await this.makePaginatedRequest<
      'endpoints',
      MalwareBytesEndpointWithAgent
    >(this.withBaseUri('nebula/v1/endpoints'), 'POST', 'endpoints', {
      'group_name.keyword': groupName,
      last_day_seen_after: this.config.minScannedSinceISODate,
      last_day_seen_before: this.config.maxScannedSinceISODate,
    });

    for (const endpoint of endpoints) {
      await iteratee(endpoint);
    }
  }

  /**
   * Iterates each scan findings found within the requested timespan for a given endpoint.
   *
   * @param endpointId endpoint's id
   * @param iteratee receives each resource to produce entities/relationships
   */
  public async iterateScanFindings(
    endpointId: string,
    iteratee: ResourceIteratee<MalwareBytesFinding>,
  ): Promise<void> {
    const findings = await this.makePaginatedRequest<
      'detections',
      MalwareBytesFinding
    >(this.withBaseUri('nebula/v1/detections'), 'POST', 'detections', {
      machine_id: endpointId,
      status: 'found',
      sort_field: 'reported_at',
      sort_order: 'desc',
      reported_at_after: this.config.minFindingsSinceISODate,
      reported_at_before: this.config.maxFindingsSinceISODate,
    });

    for (const finding of findings) {
      await iteratee(finding);
    }
  }

  /**
   * Fetches configuration by id.
   *
   * @param policyId the ID of the policy (configuration)
   */
  public async fetchConfigurationById(
    policyId: string,
  ): Promise<MalwareBytesConfiguration | null> {
    const response = await this.request(
      this.withBaseUri(`nebula/v1/policies/${policyId}`),
    );
    const policyResponse = await response.json();

    return policyResponse;
  }
}

export function createAPIClient(
  config: CalculatedIntegrationConfig,
): APIClient {
  return new APIClient(config);
}
