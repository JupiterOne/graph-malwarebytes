import fetch, { Response } from 'node-fetch';
import * as qs from 'qs';
import {
  ExecutionHistory,
  IntegrationProviderAuthenticationError,
} from '@jupiterone/integration-sdk-core';

import { getLastDaySeenAfter, getLastDaySeenBefore } from './utils/daysRange';
import {
  DEFAULT_SCANNED_SINCE_DAYS,
  DEFAULT_FINDINGS_SINCE_DAYS,
} from './constants';

import {
  IntegrationConfig,
  MalwareBytesConfiguration,
  MalwareBytesEndpointWithAgent,
  MalwareBytesFinding,
  MalwareBytesGroup,
  PaginatedDataResponse,
} from './types';

export type ResourceIteratee<T> = (each: T) => Promise<void> | void;

export class APIClient {
  private readonly clientId: string;
  private readonly clientSecret: string;
  private readonly accountId: string;
  private readonly config: IntegrationConfig;
  private readonly executionHistory: ExecutionHistory;
  private accessToken: string;

  constructor(config: IntegrationConfig, executionHistory: ExecutionHistory) {
    this.config = config;
    this.accountId = config.accountId;
    this.clientId = config.clientId;
    this.clientSecret = config.clientSecret;
    this.executionHistory = executionHistory;
  }

  private withBaseUri(path: string): string {
    return `https://api.malwarebytes.com/${path}`;
  }

  private async request(
    uri: string,
    method: 'GET' | 'POST' | 'HEAD' = 'GET',
    body?: any,
  ): Promise<Response> {
    if (!this.accessToken) {
      await this.getAuthenticationToken();
    }

    return await fetch(uri, {
      method,
      headers: {
        Authorization: `Bearer ${this.accessToken}`,
        Accountid: this.accountId,
        'Content-Type': 'application/json',
      },
      body: body || null,
    });
  }

  private async makePaginatedRequest<K extends string, V>(
    uri: string,
    method: 'GET' | 'POST' | 'HEAD' = 'GET',
    resource: K,
    body?: any,
  ): Promise<V[]> {
    const results: V[] = [];
    let nextCursor = '';

    do {
      const response = await this.request(
        uri,
        method,
        JSON.stringify({
          ...body,
          page_size: 500,
          next_cursor: nextCursor,
        }),
      );

      const responseJson: PaginatedDataResponse<K, V[]> = await response.json();

      if (responseJson) {
        nextCursor = responseJson.next_cursor;
        results.push(...responseJson[resource]);
      }
    } while (nextCursor && nextCursor.length > 0);

    return results;
  }

  private async getAuthenticationToken() {
    const getAuthTokenEndpoint = this.withBaseUri('oauth2/token');
    const response = await fetch(getAuthTokenEndpoint, {
      method: 'POST',
      headers: {
        Authorization: `Basic ${Buffer.from(
          `${this.clientId}:${this.clientSecret}`,
        ).toString('base64')}`,
        'Content-Type': 'application/x-www-form-urlencoded',
      },
      body: qs.stringify({
        scope: 'read',
        grant_type: 'client_credentials',
      }),
    });

    try {
      const body = await response.json();
      this.accessToken = body.access_token;
    } catch (e) {
      throw new IntegrationProviderAuthenticationError({
        cause: e,
        endpoint: getAuthTokenEndpoint,
        status: response.status,
        statusText: response.statusText,
      });
    }
  }

  public async verifyAuthentication(): Promise<void> {
    if (!this.accessToken) {
      await this.getAuthenticationToken();
    }

    const groupsApiRoute = this.withBaseUri('nebula/v1/groups');
    const response = await this.request(groupsApiRoute);

    if (!response.ok) {
      throw new IntegrationProviderAuthenticationError({
        endpoint: groupsApiRoute,
        status: response.status,
        statusText: response.statusText,
      });
    }
  }

  /**
   * Iterates each group in the provider.
   *
   * @param iteratee receives each resource to produce entities/relationships
   */
  public async iterateGroups(
    iteratee: ResourceIteratee<MalwareBytesGroup>,
  ): Promise<void> {
    const response = await this.request(this.withBaseUri('nebula/v1/groups'));
    const groupsResponse = await response.json();

    for (const group of groupsResponse.groups) {
      await iteratee(group);
    }
  }

  /**
   * Iterates each endpoint found within the requested timespan for a given group.
   *
   * @param groupName group's name
   * @param iteratee receives each resource to produce entities/relationships
   */
  public async iterateEndpoints(
    groupName: string,
    iteratee: ResourceIteratee<MalwareBytesEndpointWithAgent>,
  ): Promise<void> {
    const lastDaySeenAfter = getLastDaySeenAfter({
      minSinceDays: this.config.minScannedSinceDays
        ? parseInt(this.config.minScannedSinceDays, 10)
        : DEFAULT_SCANNED_SINCE_DAYS,
      lastSuccessful: this.executionHistory.lastSuccessful,
    });

    const lastDaySeenBefore = getLastDaySeenBefore({
      startedOn: this.executionHistory.current.startedOn,
    });

    const endpoints = await this.makePaginatedRequest<
      'endpoints',
      MalwareBytesEndpointWithAgent
    >(this.withBaseUri('nebula/v1/endpoints'), 'POST', 'endpoints', {
      'group_name.keyword': groupName,
      last_day_seen_after: lastDaySeenAfter,
      last_day_seen_before: lastDaySeenBefore,
    });

    for (const endpoint of endpoints) {
      await iteratee(endpoint);
    }
  }

  /**
   * Iterates each scan findings found within the requested timespan for a given endpoint.
   *
   * @param endpointId endpoint's id
   * @param iteratee receives each resource to produce entities/relationships
   */
  public async iterateScanFindings(
    endpointId: string,
    iteratee: ResourceIteratee<MalwareBytesFinding>,
  ): Promise<void> {
    const lastDaySeenAfter = getLastDaySeenAfter({
      minSinceDays: this.config.minFindingsSinceDays
        ? parseInt(this.config.minFindingsSinceDays, 10)
        : DEFAULT_FINDINGS_SINCE_DAYS,
      lastSuccessful: this.executionHistory.lastSuccessful,
    });

    const lastDaySeenBefore = getLastDaySeenBefore({
      startedOn: this.executionHistory.current.startedOn,
    });

    const findings = await this.makePaginatedRequest<
      'detections',
      MalwareBytesFinding
    >(this.withBaseUri('nebula/v1/detections'), 'POST', 'detections', {
      machine_id: endpointId,
      status: 'found',
      sort_field: 'reported_at',
      sort_order: 'desc',
      reported_at_after: lastDaySeenAfter,
      reported_at_before: lastDaySeenBefore,
    });

    for (const finding of findings) {
      await iteratee(finding);
    }
  }

  /**
   * Fetches configuration by id.
   *
   * @param policyId the ID of the policy (configuration)
   */
  public async fetchConfigurationById(
    policyId: string,
  ): Promise<MalwareBytesConfiguration | null> {
    const response = await this.request(
      this.withBaseUri(`nebula/v1/policies/${policyId}`),
    );
    const policyResponse = await response.json();

    return policyResponse;
  }
}

export function createAPIClient(
  config: IntegrationConfig,
  executionHistory: ExecutionHistory,
): APIClient {
  return new APIClient(config, executionHistory);
}
